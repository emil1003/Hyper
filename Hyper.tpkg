--[[
    Built using Titanium Packager (Harry Felton - hbomb79)

    Install pakager, and other Titanium developer tools via 'pastebin run 5B9k1jZg'
]]
local args, exportDirectory = { ... }, ""
if args[ 1 ] and args[ 1 ] ~= "--" then exportDirectory = args[ 1 ] or "" end
table.remove( args, 1 )
if args[ 1 ] == "--" then table.remove( args, 1 ) end
local classSource = {
  [ "ListView.ti" ] = "--[[\
\009Displays nodes as a vertically scrolling list\
]]\
\
class \"ListView\" extends \"ScrollContainer\" {\
\009totalNodeHeight = 0;\
}\
\
--[[\
\009@constructor\
\009@desc Resolves constructor arguments and invokes super.\
\009@param <table - structure>*\
]]\
function ListView:__init__( ... )\
\009self:super( ... )\
\
\009--self.xScrollAllowed = false\
end\
\
--[[\
\009@instance\
\009@desc Inserts a node at the bottom of the list.\
\009@param <Node - node>\
]]\
function ListView:addNode( node )\
\009if not Titanium.typeOf( node, \"Node\", true ) then\
\009\009return error( \"Cannot add '\"..tostring( node )..\"' as Node on '\"..tostring( self )..\"'\" )\
\009end\
\
\009if self.totalNodeHeight > 0 then\
\009\009node.Y = self.totalNodeHeight\
\009end\
\009self.totalNodeHeight = self.totalNodeHeight + node.height\
\009self.super:addNode( node )\
\009--self.width = self.width < node.width and node.width or self.width\
\009self.changed = true\
end\
\
function ListView:clearNodes()\
\009self.super:clearNodes()\
\009self.totalNodeHeight = 0\
end\
\
--[[\
\009@instance\
\009@desc Draw the node.\
\009@param <boolean - force>*\
]]\
function ListView:draw( force )\
\009if self.changed or force then\
\009\009self.super:draw()\
\009end\
end",
  [ "ClockView.ti" ] = "--[[\
\009A simple class \"that\" makes displaying a clock easy.\
\009NOTE: Add :update() to Application:schedule(), preferably with a .5 sec delay and repeating.\
]]\
class \"ClockView\" extends \"Node\" {\
\009clockType = 1;\
\
\009color = colors.lightGray;\
\009backgroundColor = colors.gray;\
}\
\
--[[\
\009@constructor\
\009@desc Init instance and watch the property 'text'\
\009@param <table - structure>*\
]]\
function ClockView:__init__( ... )\
\009self:resolve( ... )\
\009self:super()\
\
\009self:register( \"color\", \"backgroundColor\" )\
\
    self:update()\
end\
\
--[[\
\009@instance\
\009@desc Updates the clock text (clockType 1 = 24 hr clock)\
]]\
function ClockView:update()\
\009local newTime = textutils.formatTime( os.time(), self.clockType == 1 and true or false )\
\009if self.text ~= newTime then\
\009\009self.text = newTime\
\009\009self.width = #newTime\
\009\009self.changed = true\
\009end\
end\
\
--[[\
\009@instance\
\009@desc Draws the node\
\009@param <boolean - force>*\
]]\
function ClockView:draw( force )\
\009if self.changed or force then\
\009\009self.canvas:drawTextLine( 1, 1, self.text, self.color, self.backgroundColor )\
\009end\
end\
\
configureConstructor {\
\009argumentTypes = { clockType = \"number\", color = \"colour\", backgroundColor = \"colour\" }\
}",
}
local vfsAssets = {
  [ "Hyper/Lua/Hyper.lua" ] = "--[[\
\009Hyper, the easy-to-use ComputerCraft OS.\
\009Evolution of the original EmilOS.\
\009(c) 2018 Emil Inc.\
\
\009Titanium is (c) 2016 Harry Felton.\
]]\
\
-- Application Instance\
local App = Application():set({\
\009terminatable = true,\
\009color = colors.black,\
\009backgroundColor = colors.white\
})\
\
App:importFromTML( \"Hyper/UI/TML/Hyper.tml\" )\
App:addTheme( Theme.fromFile( \"Hyper\", \"Hyper/UI/Themes/Hyper.theme\" ) )\
\
local function getNode( id )\
\009return App:query(id).result[1]\
end\
\
-- Get nodes and organize them\
local Topbar = {\
\009self = getNode \"#Topbar\",\
\
\009menuButton = getNode \"#TopbarMenuButton\",\
\
\009clock = getNode \"#TopbarClock\",\
\009searchButton = getNode \"#TopbarSearchButton\",\
\009sidebarButton = getNode \"#TopbarSidebarButton\",\
\
\009dragStartedOn = false\
}\
\
local AppList = {\
\009--self = getNode \"#AppList\", Not yet implemented\
\
\009container = getNode \"#AppListContainer\"\
}\
\
local Sidebar = {\
\009self = getNode \"#Sidebar\",\
\
\009tabContainer = getNode \"#SidebarTabContainer\",\
\
\009Notifications = {\
\009\009self = getNode \"#SidebarNotifications\",\
\009\009list = getNode \"#SidebarNotificationsList\"\
\009},\
\
\009isOpen = false\
}\
\
local Dialog = {\
\009self = getNode \"#Dialog\",\
\
\009label = getNode \"#DialogLabel\",\
\
\009rightButton = getNode \"#DialogButtonRight\",\
\009leftButton = getNode \"#DialogButtonLeft\"\
}\
\
-- Stupid fixes that shouldn't have to be done like this, but it's the only way.\
function Sidebar:toggle() -- Can't be inside Sidebar because reasons\
\009if Sidebar.isOpen then\
\009\009Sidebar.self:animate( \"showSidebar\", \"X\", App.width + 1, 0.3, \"inCubic\" )\
\009else\
\009\009Sidebar.self:animate( \"hideSidebar\", \"X\", App.width - Sidebar.self.width + 1, 0.3, \"outCubic\" )\
\009end\
\009Sidebar.isOpen = not Sidebar.isOpen\
end\
\
function Dialog:create( label, buttonRight, buttonLeft, funcRight, funcLeft )\
\009Dialog.label:setText( label )\
\009Dialog.rightButton:setText( buttonRight and buttonRight or \"\" )\
\009Dialog.rightButton:off( \"trigger\" ):on( \"trigger\", function()\
\009\009Dialog.self:animate( \"dialog\", \"Y\", App.height + 1, 0.3, \"inCubic\" )\
\009\009if funcRight then funcRight() end\
\009end)\
\009Dialog.leftButton:setText( buttonLeft and buttonLeft or \"\" )\
\009Dialog.leftButton:off( \"trigger\" ):on( \"trigger\", function()\
\009\009Dialog.self:animate( \"dialog\", \"Y\", App.height + 1, 0.3, \"inCubic\" )\
\009\009if funcLeft then funcLeft() end\
\009end)\
\
\009Dialog.self:animate( \"dialog\", \"Y\", (App.height - Dialog.self.height) / 2, 0.3, \"outCubic\" )\
end\
\
Sidebar.tabContainer:set({ -- TabbedPageContainer doesn't apply colors from theme\
\009tabColour = colors.black,\
\009tabBackgroundColour = colors.lightGray,\
\009selectedTabColour = colors.white,\
\009selectedTabBackgroundColour = colors.lightBlue\
})\
\
-- Setup event handlers\
Topbar.menuButton:on( \"trigger\", function()\
\009if Topbar.Menu then\
\009\009App:removeNode( Topbar.Menu )\
\009end\
\009Topbar.Menu = App:addNode( ContextMenu({\
\009\009{\"button\", \" About Hyper \", function()\
\009\009\009App:removeNode( Topbar.Menu )\
\009\009\009Dialog.create( nil --[[ why? ]], \"Hyper\\n\".._HOST, \"OK\" )\
\009\009end},\
\009\009{\"rule\"},\
\009\009{\"button\", \" Settings \", function() end},\
\009\009{\"rule\"},\
\009\009{\"menu\", \" Leave...   \\16 \", {\
\009\009\009{\"button\", \" Logout \", function()\
\009\009\009\009App:removeNode( Topbar.Menu )\
\009\009\009\009Dialog:create( \"Log out?\", \"Yes\", \"No\", function() App:stop() end )\
\009\009\009end},\
\009\009\009{\"button\", \" Reboot \", function() os.reboot() end},\
\009\009\009{\"button\", \" Shutdown \", function() os.shutdown() end}\
\009\009}}\
\009}, 2, Topbar.self.Y + 1 ))\
end)\
\
Topbar.sidebarButton:on( \"trigger\", Sidebar.toggle )\
Topbar.searchButton:on( \"trigger\", function() Topbar.self:animate( \"topbar\", \"Y\", 10, 0.3, \"outCubic\" ) end)\
\
Sidebar.tabContainer:selectPage( \"SidebarNotifications\" )\
\
-- Set some global event listeners\
App:on( \"mouse_click\", function( _, event )\
\009if event.button == 1 then\
\009\009if event.Y == Topbar.self.Y then Topbar.dragStartedOn = true end\
\009\009if event.X < Sidebar.self.X and Sidebar.isOpen and not Topbar.dragStartedOn then\
\009\009\009Sidebar:toggle()\
\009\009\009event.handled = true\
\009\009end\
\009end\
end):on( \"mouse_drag\", function( _, event )\
\009if event.button == 1 then\
\009\009if Topbar.dragStartedOn then\
\009\009\009Topbar.self.Y = event.Y\
\009\009\009event.handled = true\
\009\009end\
\009end\
end):on( \"mouse_up\", function()\
\009Topbar.dragStartedOn = false\
end)\
\
-- Start Titanium event loop\
App:schedule( function() Topbar.clock:update() end, 0.5, true )\
App:start()",
  [ "Hyper/UI/Themes/Hyper.theme" ] = "<!-- Hyper Theme -->\
\
<!-- Application -->\
<Container class=\"Application\">\
\009<color>black</color>\
\009<backgroundColor>black</backgroundColor>\
</Container>\
\
<!-- Topbar -->\
<Container class=\"Topbar\">\
\009<color>lightGray</color>\
\009<backgroundColor>gray</backgroundColor>\
</Container>\
\
<Button class=\"Topbar\">\
\009<color>lightGray</color>\
\009<backgroundColor>gray</backgroundColor>\
\009<activeColor>white</activeColor>\
\009<activeBackgroundColor>lightBlue</activeBackgroundColor>\
</Button>\
\
<ClockView class=\"Topbar Clock\">\
\009<color>lightGray</color>\
\009<backgroundColor>gray</backgroundColor>\
</ClockView>\
\
<ContextMenu>\
\009<color>white</color>\
\009<backgroundColor>gray</backgroundColor>\
</ContextMenu>\
\
<!-- App List -->\
<Container class=\"AppListContainer\">\
\009<color>white</color>\
\009<backgroundColor>cyan</backgroundColor>\
</Container>\
\
<!-- Sidebar -->\
<Container class=\"Sidebar\">\
\009<color>black</color>\
\009<backgroundColor>lightGray</backgroundColor>\
</Container>\
\
<!-- TabbedPageContainer is handled in the Lua file -->\
\
<!-- Dialogs -->\
<Window class=\"Dialog\">\
\009<color>black</color>\
\009<backgroundColor>white</backgroundColor>\
</Window>\
\
<Button class=\"DialogButton\">\
\009<color>cyan</color>\
\009<activeColor>white</activeColor>\
\009<activeBackgroundColor>lightBlue</activeBackgroundColor>\
</Button>",
  [ "Hyper/UI/TML/Hyper.tml" ] = "<Container X=1 Y=1 width=\"$application.width\" height=\"$application.height\" id=\"Application\" class=\"Application\">\
\
\009<!-- Topbar -->\
\009<Container X=1 Y=1 width=\"$application.width\" height=1 id=\"Topbar\" class=\"Topbar\">\
\
\009\009<Button X=2 Y=1 width=\"$#self.text\" text=\" Hyper \" id=\"TopbarMenuButton\" class=\"Topbar MenuButton\" />\
\
\009\009<ClockView X=\"$(parent.width - self.width) / 2\" Y=1 width=\"$#self.text\" id=\"TopbarClock\" class=\"Topbar Clock\" />\
\
\009\009<Button X=\"${#TopbarSidebarButton}.X - self.width\" Y=1 width=\"$#self.text\" text=\" o \" id=\"TopbarSearchButton\" class=\"Topbar SearchButton\" />\
\009\009<Button X=\"$parent.width - self.width + 1\" Y=1 width=\"$#self.text\" text=\" = \" id=\"TopbarSidebarButton\" class=\"Topbar SidebarButton\" />\
\
\009</Container>\
\
\009<!-- App List -->\
\009<Container X=1 Y=\"${#Topbar}.Y + 1\" width=\"$application.width\" height=\"$application.height - 1\" id=\"AppListContainer\" class=\"AppListContainer\" />\
\
\009<!-- Right Sidebar -->\
\009<Container X=\"$application.width + 1\" Y=\"${#Topbar}.Y + 1\" width=20 height=\"$application.height - 1\" id=\"Sidebar\" class=\"Sidebar\">\
\009\009<TabbedPageContainer X=1 Y=1 width=\"$parent.width\" height=\"$parent.height\" id=\"SidebarTabContainer\" class=\"Sidebar TabContainer\">\
\
\009\009\009<Page id=\"SidebarNotifications\" name=\"=\" xScrollAllowed=\"false\">\
\009\009\009\009<ListView X=1 Y=2 width=\"$parent.width\" height=\"$parent.height - 1\" xScrollAllowed=\"false\" id=\"SidebarNotificationsList\" />\
\009\009\009</Page>\
\
\009\009\009<Page id=\"SidebarDevices\" name=\"/\" xScrollAllowed=\"false\">\
\009\009\009</Page>\
\
\009\009</TabbedPageContainer>\
\
\009</Container>\
\
</Container>\
\
\
<!-- Dialogs -->\
<Window X=\"$(application.width - self.width) / 2\" Y=\"$application.height + 1\" width=25 height=7 titleBar=\"false\" resizeable=\"false\" moveable=\"false\" Z=24 id=\"Dialog\" class=\"Dialog\">\
\009\
\009<Label X=2 Y=2 text=\"\" id=\"DialogLabel\" />\
\
\009<Button X=\"$parent.width - self.width\" Y=\"$parent.height - 1\" width=\"$#self.text\" text=\" \" id=\"DialogButtonRight\" class=\"DialogButton\"/>\
\009<Button X=\"${#DialogButtonRight}.X - self.width - 1\" Y=\"$parent.height - 1\" width=\"$#self.text\" text=\" \" id=\"DialogButtonLeft\" class=\"DialogButton\"/>\
\
</Window>",
}local env = type( getfenv ) == "function" and getfenv() or _ENV or _G
if env.TI_VFS_RAW then env = env.TI_VFS_RAW end
local fallbackFS = env.fs
local RAW = setmetatable({
    fs = setmetatable( {}, { __index = _G["fs"] }),
    os = setmetatable( {}, { __index = _G["os"] } )
}, { __index = env })

local VFS = RAW["fs"]
local VFS_ENV = setmetatable({},{__index = function( _, key )
    if key == "TI_VFS_RAW" then return RAW end
    return RAW[ key ]
end})

VFS_ENV._G = VFS_ENV
VFS_ENV._ENV = VFS_ENV

local VFS_DIRS = {
  [ "Hyper/UI" ] = true,
  [ "Hyper/Lua" ] = true,
  Hyper = true,
  [ "Hyper/UI/TML" ] = true,
  [ "Hyper/UI/Themes" ] = true,
}
local matches = { ["^"] = "%^", ["$"] = "%$", ["("] = "%(", [")"] = "%)", ["%"] = "%%", ["*"] = "[^/]*", ["."] = "%.", ["["] = "%[", ["]"] = "%]", ["+"] = "%+", ["-"] = "%-" }


function VFS_ENV.load(src, name, mode, env)
    return load( src, name or '(load)', mode, env or VFS_ENV )
end

function VFS_ENV.loadstring(src, name)
    return VFS_ENV.load( src, name, 't', VFS_ENV )
end

function VFS_ENV.loadfile(file, env)
    local _ENV = VFS_ENV
    local h = fs.open( file, "r" )
    if h then
        local fn, e = load(h.readAll(), fs.getName(file), 't', env or VFS_ENV)
        h.close()
        return fn, e
    end

    return nil, 'File not found'
end
if type( setfenv ) == "function" then setfenv( VFS_ENV.loadfile, VFS_ENV ) end

function VFS_ENV.os.run( _tEnv, _sPath, ... )
    local _ENV = VFS_ENV
    local tArgs, tEnv = { ... }, _tEnv

    setmetatable( tEnv, { __index = VFS_ENV } )
    local fnFile, err = loadfile( _sPath, tEnv )
    if fnFile then
        local ok, err = pcall( function()
            fnFile( table.unpack( tArgs ) )
        end )
        if not ok then
            if err and err ~= "" then
                printError( err )
            end
            return false
        end
        return true
    end
    if err and err ~= "" then
        printError( err )
    end
    return false
end

local tAPIsLoading = {}
function VFS_ENV.os.loadAPI( _sPath )
    local _ENV, sName = VFS_ENV, fs.getName( _sPath )
    if tAPIsLoading[sName] == true then
        printError( "API "..sName.." is already being loaded" )
        return false
    end
    tAPIsLoading[sName] = true

    local tEnv = setmetatable( {}, { __index = VFS_ENV } )
    local fnAPI, err = loadfile( _sPath, tEnv )
    if fnAPI then
        local ok, err = pcall( fnAPI )
        if not ok then
            printError( err )
            tAPIsLoading[sName] = nil
            return false
        end
    else
        printError( err )
        tAPIsLoading[sName] = nil
        return false
    end

    local tAPI = {}
    for k,v in pairs( tEnv ) do if k ~= "_ENV" then tAPI[k] =  v end end

    VFS_ENV[sName], tAPIsLoading[sName] = tAPI, nil
    return true
end

VFS_ENV.os.loadAPI "/rom/apis/io"
function VFS_ENV.dofile(file)
    local _ENV = VFS_ENV
    local fn, e = loadfile(file, VFS_ENV)

    if fn then return fn()
    else error(e, 2) end
end
if type( setfenv ) == "function" then setfenv( VFS_ENV.dofile, VFS_ENV ) end

function VFS.open( path, mode )
    path = fs.combine( "", path )
    if vfsAssets[ path ] then
        if mode == "w" or mode == "wb" or mode == "a" or mode == "ab" then
            return error("Cannot open file in mode '"..tostring( mode ).."'. File is inside of Titanium VFS and is read only")
        end

        local content, handle = vfsAssets[ path ], {}
        if mode == "rb" then
            handle.read = function()
                if #content == 0 then return end
                local b = content:sub( 1, 1 ):byte()

                content = content:sub( 2 )
                return b
            end
        end

        handle.readLine = function()
            if #content == 0 then return end

            local line, rest = content:match "^([^\n\r]*)(.*)$"

            content = rest and rest:gsub("^[\n\r]", "") or ""
            return line or content
        end

        handle.readAll = function()
            if #content == 0 then return end

            local c = content
            content = ""

            return c
        end

        handle.close = function() content = "" end

        return handle
    else return fallbackFS.open( fs.combine( exportDirectory, path ), mode ) end
end

function VFS.isReadOnly( path )
    path = fs.combine( "", path )
    if vfsAssets[ path ] then return true end

    return fallbackFS.isReadOnly( fs.combine( exportDirectory, path ) )
end

function VFS.getSize( path )
    return vfsAssets[ path ] and #vfsAssets[ path ] or fallbackFS.getSize( path )
end

function VFS.list( target )
    target = fs.combine( "", target )
    local list = fallbackFS.isDir( target ) and fallbackFS.list( target ) or {}

    local function addResult( res )
        for i = 1, #list do if list[ i ] == res then return end end
        list[ #list + 1 ] = res
    end

    if VFS_DIRS[ target ] then
        for path in pairs( vfsAssets ) do
            if path:match( ("^%s/"):format( target ) ) then
                addResult( path:match( ("^%s/([^/]+)"):format( target ) ) )
            end
        end
    elseif target == "" then
        for path in pairs( vfsAssets ) do addResult( path:match "^([^/]+)" ) end
    end

    return list
end

function VFS.find( target )
    target = fs.combine( "", target )
    local list = fallbackFS.find( target ) or {}

    target = ("^(%s)(.*)$"):format( target:gsub( ".", matches ) )
    for path in pairs( vfsAssets ) do
        local res, tail = path:match( target )
        if res and ( tail == "" or tail:sub( 1, 1 ) == "/" ) then
            local isMatch
            for i = 1, #list do if list[ i ] == res then isMatch = true; break end end

            if not isMatch then list[ #list + 1 ] = res end
        end
    end

    return list
end

function VFS.isDir( path )
    path = fs.combine( "", path )
    return VFS_DIRS[ path ] or fallbackFS.isDir( fs.combine( exportDirectory, path ) )
end

function VFS.exists( path )
    path = fs.combine( "", path )
    if vfsAssets[ path ] or VFS_DIRS[ path ] then return true end

    return fallbackFS.exists( fs.combine( exportDirectory, path ) )
end
if not fs.exists( "/.tpm/bin/tpm" ) then
    local h = http.get "https://gitlab.com/hbomb79/Titanium-Package-Manager/raw/master/tpm"
    if not h then return error "Failed to download TPM" end

    local f = fs.open( "/.tpm/bin/tpm", "w" )
    f.write( h.readAll() )
    h.close()
    f.close()
end

local ok, err = loadfile "/.tpm/bin/tpm"
if not ok then return error("Failed to load TPM '"..tostring( err ).."'") end

ok( "--fetch", "--disposable", "--depend", shell.getRunningProgram(), "install", "Titanium:latest" )
local FAILURE = "Failed to execute Titanium package. Latest Titanium version cannot be found %s (/.tpm/cache)"
if not fs.exists("/.tpm/cache") then
    return error( FAILURE:format "because TPM cache is missing" )
end

local cacheHandle = fs.open("/.tpm/cache", "r")
local cache = textutils.unserialise( cacheHandle.readAll() )
cacheHandle.close()

if not cache then
    return error( FAILURE:format "because TPM cache is malformed" )
elseif not cache.Titanium then
    return error( FAILURE:format "because TPM cache missing Titanium version information" )
end
if not VFS_ENV.Titanium then VFS_ENV.dofile( "/.tpm/packages/Titanium/"..cache.Titanium[1] ) end
local ti = VFS_ENV.Titanium
if not ti then
    return error "Failed to execute Titanium package. Titanium is not loaded. Please load Titanium before executing this package (or use a --titanium-init), or repackage this application using the --titanium flag."
end

local loaded = {}
local function loadClass( name, source )
    if not source then return error( "Failed to load class '"..name.."'. No source found within class assets" )
    elseif loaded[ name ] then return end

    local className = name:gsub( "%..*", "" )
    if not ti.getClass( className ) then
        local output, err = ( VFS_ENV or _G ).loadstring( source, name )
        if not output or err then return error( "Failed to load Lua chunk. File '"..name.."' has a syntax error: "..tostring( err ), 0 ) end

        local ok, err = pcall( output )
        if not ok or err then return error( "Failed to execute Lua chunk. File '"..name.."' crashed: "..tostring( err ), 0 ) end

        local class = ti.getClass( className )
        if class then
            if not class:isCompiled() then class:compile() end
            loaded[ name ] = true
        else return error( "File '"..name.."' failed to create class '"..className.."'" ) end
    else
        print( "WARNING: Class " .. className .. " failed to load because a class with the same name already exists." )
    end
end

ti.setClassLoader(function( c )
    local name = classSource[ c .. ".lua" ] and c .. ".lua" or c .. ".ti"
    loadClass( name, classSource[ name ] )
end)
for name, source in pairs( classSource ) do
    loadClass( name, source )
end
local fn, err = VFS_ENV.loadfile 'Hyper/Lua/Hyper.lua'if fn then fn( unpack( args ) ) else return error('Failed to run file from bundle: "'..tostring( err )..'"') end
